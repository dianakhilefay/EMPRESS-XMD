// === fakecall.js ===
// Adapted from Noroshi bot for Malvin-Lite
const { createCanvas, loadImage } = require('canvas');
const { downloadContentFromMessage } = require("@whiskeysockets/baileys");
const fakevCard = require('../lib/fakevcard');

module.exports = {
    pattern: "fakecall",
    desc: "Create a fake call screenshot",
    category: "fun",
    react: "üì±",
    filename: __filename,
    use: ".fakecall Name|Duration (reply to image)",
    
    execute: async (conn, mek, m, { from, args, reply }) => {
        try {
            // Check if replying to an image
            const quotedMsg = mek.message?.extendedTextMessage?.contextInfo?.quotedMessage;
            
            if (!quotedMsg || !quotedMsg.imageMessage) {
                return reply(
                    `üì± **Fake Call Generator**\n\n` +
                    `**Usage:** Reply to a photo with \`.fakecall Name|Duration\`\n\n` +
                    `**Examples:**\n` +
                    `‚Ä¢ \`.fakecall John Doe|00:08\`\n` +
                    `‚Ä¢ \`.fakecall Sarah|01:25\`\n` +
                    `‚Ä¢ \`.fakecall Boss|00:03\`\n\n` +
                    `üì∏ **Note:** You must reply to an image to use as the caller's avatar.`
                );
            }

            const input = args.join(' ');
            const [name, duration] = input.split('|').map(s => s?.trim());
            
            if (!name || !duration) {
                return reply(
                    `‚ùå Invalid format!\n\n` +
                    `**Correct usage:** \`.fakecall Name|Duration\`\n` +
                    `**Example:** \`.fakecall John Doe|00:08\``
                );
            }

            await conn.sendMessage(from, {
                react: { text: '‚è≥', key: mek.key }
            });

            await reply('üì± Creating fake call screenshot... Please wait.');

            // Download the quoted image
            const stream = await downloadContentFromMessage(quotedMsg.imageMessage, "image");
            let imageBuffer = Buffer.from([]);
            for await (const chunk of stream) {
                imageBuffer = Buffer.concat([imageBuffer, chunk]);
            }

            // Load images
            const avatar = await loadImage(imageBuffer);
            const bg = await loadImage('https://files.catbox.moe/pmhptv.jpg');

            // Create canvas
            const canvas = createCanvas(720, 1280);
            const ctx = canvas.getContext('2d');

            // Draw background
            ctx.drawImage(bg, 0, 0, 720, 1280);

            // Draw caller name
            ctx.font = 'bold 40px sans-serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 3;
            ctx.fillText(name, 360, 150);

            // Draw call duration
            ctx.font = '30px sans-serif';
            ctx.fillStyle = '#d1d1d1';
            ctx.shadowBlur = 2;
            ctx.fillText(duration, 360, 200);

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            // Draw circular avatar
            ctx.save();
            ctx.beginPath();
            ctx.arc(360, 635, 160, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();
            
            // Calculate aspect ratio for proper image scaling
            const aspectRatio = avatar.width / avatar.height;
            let drawWidth = 320;
            let drawHeight = 320;
            let drawX = 200;
            let drawY = 475;
            
            if (aspectRatio > 1) {
                drawHeight = drawWidth / aspectRatio;
                drawY = 635 - (drawHeight / 2);
            } else if (aspectRatio < 1) {
                drawWidth = drawHeight * aspectRatio;
                drawX = 360 - (drawWidth / 2);
            }
            
            ctx.drawImage(avatar, drawX, drawY, drawWidth, drawHeight);
            ctx.restore();

            const buffer = canvas.toBuffer('image/png');

            await conn.sendMessage(from, {
                image: buffer,
                caption: `üì± **Fake Call Created Successfully!**\n\n` +
                        `üë§ **Caller:** ${name}\n` +
                        `‚è±Ô∏è **Duration:** ${duration}\n` +
                        `üì∏ **Quality:** HD (720x1280)\n\n` +
                        `üí° **Tip:** Screenshot this for the most realistic effect!\n\n` +
                        `> ¬© Generated by ${process.env.BOT_NAME || 'Malvin Lite'}`
            }, { quoted: fakevCard });

            await conn.sendMessage(from, {
                react: { text: '‚úÖ', key: mek.key }
            });

        } catch (error) {
            console.error('Fake call error:', error);
            await conn.sendMessage(from, {
                react: { text: '‚ùå', key: mek.key }
            });
            
            let errorMsg = '‚ùå Failed to create fake call: ';
            if (error.message.includes('Canvas')) {
                errorMsg += 'Image processing failed. Try with a different image.';
            } else if (error.message.includes('download')) {
                errorMsg += 'Failed to download image. Please try again.';
            } else {
                errorMsg += error.message;
            }
            
            return reply(errorMsg);
        }
    }
};